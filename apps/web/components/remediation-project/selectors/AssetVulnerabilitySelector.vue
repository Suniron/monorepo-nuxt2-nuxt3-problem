<template>
  <div>
    <div class="d-flex align-center">
      <v-combobox
        :items="sortedAssets"
        :value="selectedAssetData"
        item-text="asset.name"
        item-value="asset.id"
        @input="selectAsset"
        class="left-border-radius"
        dense
        filled
        solo
        deletable-chips
        label="Select an asset"
        placeholder="Select an asset"
        return-object
        hide-details
        :menu-props="{
          bottom: true,
          offsetY: true,
          closeOnClick: true
        }"
      >
        <template #item="{ item: { asset } }">
          <span v-if="asset.childrenIds.length" class="mr-2">
            ({{
              asset.childrenIds.length > 1
                ? `${asset.childrenIds.length} sub-assets`
                : `${asset.childrenIds.length} sub-asset`
            }})
          </span>
          {{ asset.name }}
        </template>
        <template
          v-if="selectedAssetData && selectedAssetData.asset.childrenIds.length"
          #append
        >
          +{{ selectedAssetData.asset.childrenIds.length }}
        </template>
      </v-combobox>
      <v-combobox
        :items="selectedAssetData ? selectedAssetData.vulnerabilities : []"
        :value="selectedVulnerabilities"
        :disabled="!selectedAssetData"
        item-text="name"
        item-value="vastId"
        @input="selectVulnerabilities"
        class="right-border-radius asset-vulnerability-combobox"
        dense
        chips
        small-chips
        filled
        :solo-inverted="!selectedAssetData"
        :solo="Boolean(selectedAssetData)"
        multiple
        deletable-chips
        label="Select a vulnerability"
        placeholder="Select a vulnerability"
        return-object
        hide-details
        :menu-props="{
          bottom: true,
          offsetY: true,
          closeOnClick: true
        }"
      >
        <template #selection="{ index }">
          <span v-if="index === 0">
            {{ selectedVulnerabilities.length }}
            {{
              selectedVulnerabilities.length > 1
                ? 'Vulnerabilities'
                : 'Vulnerability'
            }}
            selected
          </span>
        </template>
        <template #prepend-item>
          <v-checkbox
            class="ml-4"
            :value="areAllAssetsVulnerabilitiesSelected"
            @change="selectAllVulnerabilitiesClick"
            :indeterminate="
              selectedVulnerabilities.length > 0 &&
                !areAllAssetsVulnerabilitiesSelected
            "
            :label="
              selectedVulnerabilities.length ? 'Unselect all' : 'Select all'
            "
          ></v-checkbox>
          <hr />
        </template>
      </v-combobox>
      <v-btn
        color="primary"
        class="mx-5 align-center"
        :disabled="!selectedAssetData || selectedVulnerabilities.length === 0"
        @click="addAssetVulnerabilities"
      >
        Add to project
        <v-icon class="ml-2">mdi-plus-box-multiple</v-icon>
      </v-btn>
    </div>
  </div>
</template>

<script>
import _ from 'lodash'

const SUPER_ASSET_TYPES = ['MISSION', 'UNIT', 'NETWORK', 'USERGROUP']

/**
 * @typedef {{
 *  asset: {id: number, name: string, type: string, childrenIds: number[]},
 *  vulnerabilities: {id: number, name: string, vastId: number}[]
 * }} assetDataType
 */

export default {
  props: {
    /**
     * @type {import('vue').PropOptions<import('~/services/assets').AssetWithRelations[]>}
     */
    assetsBelongings: {
      type: Array,
      required: true
    },
    /**
     * @type {import('vue').PropOptions<import('~/services/vulnerabilities').VulnerabilityWithAssets[]>}
     */
    vulnerabilities: {
      type: Array,
      required: true
    }
  },
  data() {
    return {
      /**
       * @type {import('~/services/assets').AssetWithRelations[]}
       */
      assetsBelongingsCopy: [],
      /**
       * @type {assetDataType[]}
       */
      assetsData: [],
      /**
       * @type {import('~/services/vulnerabilities').VulnerabilityWithAssets[]}
       */
      vulnerabilitiesCopy: [],
      /**
       * @type {assetDataType}
       */
      selectedAssetData: null,
      selectedVulnerabilities: []
    }
  },
  computed: {
    /**
     * Return the assets sorted by number of children
     * @returns {import('~/services/assets').AssetWithRelations[]}
     */
    sortedAssets() {
      const sorted = [...this.assetsData].sort((a, b) => {
        const diff = b.asset.childrenIds.length - a.asset.childrenIds.length
        if (diff === 0) {
          if (
            SUPER_ASSET_TYPES.includes(a.asset.type) &&
            !SUPER_ASSET_TYPES.includes(b.asset.type)
          ) {
            return -1
          }
          if (
            !SUPER_ASSET_TYPES.includes(a.asset.type) &&
            SUPER_ASSET_TYPES.includes(b.asset.type)
          ) {
            return 1
          }
          return a.asset.name.localeCompare(b.asset.name, 'en', {
            numeric: true
          })
        }
        return diff
      })
      const numberOfSuperAssets = sorted.reduce((acc, assetData) => {
        return (
          acc +
          (SUPER_ASSET_TYPES.includes(assetData.asset.type.toUpperCase())
            ? 1
            : 0)
        )
      }, 0)

      if (numberOfSuperAssets) {
        sorted.splice(
          numberOfSuperAssets,
          0,
          {
            divider: true
          },
          {
            header: 'Assets'
          }
        )
        sorted.unshift({
          header: 'Super assets'
        })
      } else {
        sorted.splice(numberOfSuperAssets, 0, {
          header: 'Assets'
        })
      }
      return sorted
    },
    /**
     * @returns {{id: number, name: string, vastId: number}[]}
     */
    selectedAssetVulnerabilities() {
      return this.selectedAssetData
        ? this.selectedAssetData.vulnerabilities
        : []
    },
    /**
     * @returns {boolean}
     */
    areAllAssetsVulnerabilitiesSelected() {
      return (
        this.selectedVulnerabilities.length ===
        this.selectedAssetVulnerabilities.length
      )
    }
  },
  watch: {
    assetsBelongings: {
      handler() {
        this.getAssets()
      },
      deep: true
    },
    vulnerabilities: {
      handler() {
        this.getAssets()
      },
      deep: true
    }
  },
  created() {
    this.getAssets()
  },
  methods: {
    getAssets() {
      this.assetsBelongingsCopy = _.cloneDeep(this.assetsBelongings)
      this.vulnerabilitiesCopy = _.cloneDeep(this.vulnerabilities)

      this.vulnerabilitiesCopy.forEach((vulnerability) => {
        vulnerability.affectedAssets
          .filter(
            (affectedAsset) =>
              affectedAsset.projects.length === 0 &&
              affectedAsset.status !== 'remediated'
          )
          .forEach((affectedAsset) => {
            let assetData = this.assetsData.find(
              (asset) => asset.asset.id === affectedAsset.id
            )
            if (!assetData) {
              const assetBelonging = this.assetsBelongingsCopy.find(
                (assetBelonging) => assetBelonging.id === affectedAsset.id
              )
              assetData = {
                asset: {
                  id: affectedAsset.id,
                  name: affectedAsset.name,
                  type: affectedAsset.assetType,
                  childrenIds: assetBelonging?.childrenIds || []
                },
                vulnerabilities: []
              }
              this.assetsData.push(assetData)
            }

            assetData.vulnerabilities.push({
              id: vulnerability.id,
              name: vulnerability.name,
              vastId: affectedAsset.vastId
            })
          })
      })

      this.propagateVulnerabilitiesToParents()
    },
    propagateVulnerabilitiesToParents({ assetId, vulnerabilities } = {}) {
      if (!assetId) {
        this.assetsBelongingsCopy.forEach((assetBelonging) => {
          if (assetBelonging.parentsIds.length > 0) {
            const assetData = this.assetsData.find(
              (assetData) => assetData.asset.id === assetBelonging.id
            )
            if (assetData) {
              this.propagateVulnerabilitiesToParents({
                assetId: assetBelonging.id,
                vulnerabilities: assetData.vulnerabilities
              })
            }
          }
        })
      } else {
        const assetBelonging = this.assetsBelongingsCopy.find(
          (assetBelonging) => assetBelonging.id === assetId
        )
        assetBelonging.parentsIds.forEach((parentId) => {
          let parentAssetData = this.assetsData.find(
            (assetData) => assetData.asset.id === parentId
          )
          if (!parentAssetData) {
            const parentBelongingRelations = this.assetsBelongingsCopy.find(
              (assetBelonging) => assetBelonging.id === parentId
            )
            parentAssetData = {
              asset: {
                id: parentId,
                name: parentBelongingRelations.name,
                type: parentBelongingRelations.type,
                childrenIds: parentBelongingRelations.childrenIds || []
              },
              vulnerabilities: []
            }
            this.assetsData.push(parentAssetData)
          }
          parentAssetData.vulnerabilities = [
            ...parentAssetData.vulnerabilities,
            ...vulnerabilities.filter((vulnerability) => {
              return !parentAssetData.vulnerabilities.find(
                (parentVulnerability) =>
                  parentVulnerability.vastId === vulnerability.vastId
              )
            })
          ]
          this.propagateVulnerabilitiesToParents({
            assetId: parentAssetData.asset.id,
            vulnerabilities: parentAssetData.vulnerabilities
          })
        })
      }
    },
    selectAsset(asset) {
      this.selectedAssetData = asset
      this.selectedVulnerabilities.splice(0)
    },
    selectVulnerabilities(vulnerability) {
      this.selectedVulnerabilities.splice(
        0,
        this.selectedVulnerabilities.length,
        ...vulnerability
      )
    },
    selectAllVulnerabilitiesClick() {
      if (this.selectedVulnerabilities.length) {
        this.selectedVulnerabilities.splice(0)
      } else {
        this.selectedVulnerabilities.splice(
          0,
          this.selectedVulnerabilities.length,
          ...this.selectedAssetVulnerabilities
        )
      }
    },
    addAssetVulnerabilities() {
      this.$emit('add-asset-vulnerabilities', {
        asset: this.selectedAssetData.asset,
        vulnerabilities: this.selectedVulnerabilities
      })
      this.selectAsset(null)
    }
  }
}
</script>

<style>
.left-border-radius {
  border-radius: 5px 0 0 5px !important;
  width: 50%;
}
.right-border-radius {
  border-radius: 0 5px 5px 0 !important;
  width: 50%;
}

.v-subheader {
  font-size: 2em !important;
  font-weight: bold !important;
}
</style>
